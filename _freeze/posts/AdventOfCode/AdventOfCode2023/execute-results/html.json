{
  "hash": "7251537a0bb651549df53a2b4c3113ba",
  "result": {
    "markdown": "---\ntitle: 'Advent of Code 2023'\ndate: '2023-12-28'\n#author: \"Serban Dragne\"\ncategories: ['R','Coding']\ndescription: 'Mulled Wine and R'\nexecute:\n  message: false\n  warning: false\neditor_options:\n  chunk_output_type: console\n---\n\n\nAs I'm hip and trendy, I discovered Advent of Code \\[<https://adventofcode.com/2023>\\] just a few days before the end of the year. In the spirit of not giving every waking moment of my xmas holidays to Where Eagles Dare, mince pies and mulled wine, I decided I should at least use my noodle a bit and do these puzzles.\n\n## Day 1\n\n### Part 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(data.table)\n\nfiles <- read.csv(\"day1.csv\", header = FALSE)\ncolnames(files) <- \"input\"\n\n# create regex pattern to find the first number in a string \nfirst_pattern <- \"\\\\d\"\n\n# regex to extract the last number in a string\nlast_pattern <- \"\\\\d(?=[^\\\\d]*$)\"\n\n\n# create a new column with the first and last numbers in a string\n\nfiles$first <- (stringr::str_extract(files$input,first_pattern))\nfiles$last <- (stringr::str_extract(files$input,last_pattern))\nfiles$NewNr <- as.numeric(paste0(files$first,files$last))\n\n# sum the  column\nsum(files$NewNr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54331\n```\n:::\n:::\n\n\n### Part 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Part 2 \n\n# list of numbers as words\nnumers_as_words  <- c(\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\")\nmapping <- c(1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9)\n\n# get back a list showing the start and end points of a string that match any of the above\n# numbers as words\n\n\n#find the starting positions of where to find the numbers as words in the string\n# return the max and min of the start column\n\n#function to return the max value of the start column\nmax_start <- function(x){\n  \n   \n  # find the starting location by matching either the digits or numbers in the long string \n  starting_positions = stringr::str_locate(x, numers_as_words)[,1] \n\n  # the lowest number corresponds to the first number in the string\n  first = mapping[which(min(starting_positions,na.rm = TRUE) == starting_positions)]\n  \n  # find the last starting position for each\n  end_positions <- stringr::str_locate_all(x, numers_as_words) %>% \n    sapply(.,max) %>% \n    # replace -Inf with NA b/c it returns stupid -Inf when it cant find a match \n    replace(., is.infinite(.), NA) \n  \n\n  last = mapping[which(max(end_positions,na.rm = TRUE) == end_positions)]\n  \n  return(as.numeric(paste0(first,last)))\n\n        \n}\n\n\nfiles$newNr2 <- sapply(files$input, max_start)\n\n\n# this should work\nsum(files$newNr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54518\n```\n:::\n:::\n\n\n## Day 2\n\nAre all of these challenges just going to be regexercises?\n\n### Part 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n\n# read the data\n\ninput <- read_lines(\"day2.csv\")\n\n\ninput <- as.data.frame(input)\n\n\n# Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\n# Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\n# Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\n# Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\n# Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\n\n\n\n# separate the first column into two columns \ninput <- input %>% \n  tidyr::separate(col = input, into = c(\"Game\", \"X1\"), sep = \":\", remove = TRUE) \n\n# Determine which games would have been possible if the bag had been loaded with only \n# 12 red cubes, 13 green cubes, and 14 blue cubes. What is the sum of the IDs of those games?\n\n# part 1 \n\n\ndata.frame(\n  GameNr = 1:100,\n  max_red = stringr::str_extract_all(input$X1, \"(?<=\\\\b)(\\\\d+)(?=\\\\s*red\\\\b)\") %>% sapply(., \\(x) max(as.numeric(x))),\n  max_blue = stringr::str_extract_all(input$X1, \"(?<=\\\\b)(\\\\d+)(?=\\\\s*blue\\\\b)\") %>% sapply(., \\(x) max(as.numeric(x))),\n  max_green = stringr::str_extract_all(input$X1, \"(?<=\\\\b)(\\\\d+)(?=\\\\s*green\\\\b)\") %>% sapply(., \\(x) max(as.numeric(x)))\n) %>%\n  filter(max_red <= 12 & max_blue <= 14 & max_green <= 13) %>%\n  summarise(sum(GameNr))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sum(GameNr)\n1        2348\n```\n:::\n:::\n\n\n### Part 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# part 2\n  \ndata.frame(\n  GameNr = 1:100,\n  min_red = stringr::str_extract_all(input$X1, \"(?<=\\\\b)(\\\\d+)(?=\\\\s*red\\\\b)\") %>% sapply(., \\(x) max(as.numeric(x))),\n  min_blue = stringr::str_extract_all(input$X1, \"(?<=\\\\b)(\\\\d+)(?=\\\\s*blue\\\\b)\") %>% sapply(., \\(x) max(as.numeric(x))),\n  min_green = stringr::str_extract_all(input$X1, \"(?<=\\\\b)(\\\\d+)(?=\\\\s*green\\\\b)\") %>% sapply(., \\(x) max(as.numeric(x)))\n) %>%\n  mutate(Product = min_red * min_blue * min_green) %>%\n  summarise(sum(Product))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  sum(Product)\n1        76008\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}